---
title: "Session 1.2 Introduction to R"
output: html_notebook
---

Please see the R script to run all the code in this document (quicker than copy and pasting!). 

# Shammi's section 

### 1.2.1 Vectors

#### 1.2.1.1 Basic vectors

Vectors are the basic tools to examine and analyse your data in R. They are usually comprised of elements of the same format, for instance a numeric vector comprises of a list of numbers. In this section we will examine various ways to construct and subset a numeric vector. 

```{r}
vec1 <- c(1,2,3,4,5)
vec2 <- c(6,7,8,9,10)
```

Two vectors can also be joined into the same vector using the c() command. The two smaller vectors will appear in the new one in the order you specify:

```{r}
vec3 <- c(vec1, vec2)
vec3

vec4 <- c(vec2, vec1)
vec4
```


#### 1.2.1.2 The seq() function

Another useful feature in the world of vectors is to create a sequenece of numbers. This can be easily obtained by:

1. Using the : command
2. Using the seq() command


```{r}
1:10

seq(from=1, to=10, by=1)
```

It is not always important to write the commands "from", "to" and "by" explicitly so long as your instuctions are specified in the above order:

```{r}
seq(1, 10, 1)
```

Any feasible number can be specified in the "by" command section to create all sorts of vectors:

```{r}
seq(1, 10, 3)

seq(10, 1, -2)
```

Although "by" is the default command, we can specify another coomand: "length". The "length" command enables you to outright specify how long you would like the vector to be between your speicifed upper and lower values. In the example below, as we do not specify the command in the default order, we will need to write the commands "by" and "length" out:


```{r, eval=T}

seq(1, 10, length = 2)

seq(1, 10, length = 4)

seq(1,by=2,length=5)

```

#### 1.2.1.3 The rep() function
Another useful tool when creating vectors is the rep() function. The rep function requires one to firstly specify the object that they want to repeat, followed by the number of times the user would like it repeating:

```{r}
rep(1, 10)

rep(1:10, 3)

rep(seq(10,1,-3), 2)

rep(1:5, 1:5)

```

The "each" and "length" commands can also be specified within the rep() function to do the following:

```{r}

rep(1:3,each=3)

rep(1:3,length=10)

```

#### 1.2.1.4 Extracting values from a vector

Finally, we can extract certain values from a numeric vector using square brackets. If we want to extract the nth element of a vector, specify n within the square brackets:

```{r}

my.vector <- c(12,16,1,9,0)

vec1[2]

```

This feature can be extended to extract multiple elements from a vector. For instance if we wanted to select the first and second elements of the vector "my.vector", we would do so in the following way:

```{r}

my.vector[1:2]

my.vector[my.vector>10]

```

We are also able to remove the nth element from a vector, we can do so using the '-' command within the square brackets.

```{r}

my.vector[-2]

my.vector[-c(1:2)]

```

If we have a vector with NA values inside, we can remove them in the following way:

```{r}

my.vector2 <- c(1,2,3,NA,4,5)

my.vector2 <- my.vector2[!is.na(my.vector2)]

my.vector2
```


## 1.2.2. Matrices

Whereas vectors are one dimensional structures, matrices are two-dimensional, and contain both rows and columns. Matrices are essentially groups of vectors (all of the same length and data type). We can construct a matrix by either using the matrix(data, nrow, ncol) function or combining multiple vectors using the cbind() or rbind() functions. 


#### 1.2.2.1 The matrix() function

The matrix(data, nrow, ncol) function populates a matrix with nrow number of rows and ncol number of columns. The data length should be equal to the product of the specified number of rows and columns: 

```{r}
my.matrix1 <- matrix(1:30 ,6,5)
my.matrix1

my.matrix2 <- matrix(1:30 ,5,6)
my.matrix2
```

If we have two vectors, both of length 10, and want to combine them into a 10 x 2 matrix, we can do so by combining them in the "data" command section of the matrix() function, and subsequently specifying the number of rows or columns needed.

```{r}
numbers <- seq(1,10,1)
letters <- letters[seq( from = 1, to = 10 )]

matrix(c(numbers, letters), 10)

matrix(c(numbers, letters), 2)

```


If the data length is not a multiple of the number of rows or columns you specify, a warning message will appear. In the case below, as there are 20 elements with which we would like to populate a matrix, however, would like 3 rows, when the elements of the two vectors are exhausted, it will populate the remaining cells with elements of the vector (starting from the beginning):

```{r}

matrix(c(numbers, letters), 3)

```

#### 1.2.2.2 The cbind() and rbind() functions

The cbind() and rbind() functions are another simple way to combine vectors into a matrix, add a vector to an existing matrix, or even combine multiple matrices. Our "letters" and "numbers" vectors (defined above) are both of the same length. Therefore we can combine them into a matrix of 10 columns and 2 rows in the following way:

```{r}
rbind(numbers, letters)


```
 And into a matrix of 10 rows and 2 columns using the cbind() function:
 
```{r}

Col.comb <- cbind(numbers, letters)
Col.comb

```

As with vectors, we can extract desired elements from a matrix using square brackets. However, as unlike vectors, matrices are two-dimensional, we need to specify the row and column position of the element we would like to extract. This can be done using a comma separator. For example, to extract the element of the 5th row and 2nd column of the Col.comb matrix defined above:

```{r}

Col.comb[5,2] # Extracts the fifth row and 2nd column element 

```

If we want to extract the entire the row or column, leave the opposing arguement blank: 

```{r}

Col.comb[5,] # Extracts the fifth row

Col.comb[,2] # Extracts the 2nd column 

```



Finally, by including a minus sign, we can delete rows or columns. For example, deleting the 4th row of Col.comb is done in the following way:

```{r}

Col.comb[-4,] # Removes the 4th row


```

# Clarie's section

### 1.2.3: Dataframes

In addition to vectors and matrices, there are dataframes which are in a table format. The Iris dataset we used yesterday is an example of a dataframe.

```{r}
class(iris)

```

Before working with any data, it is helpful to check its contents first.

```{r}
head(iris)
nrow(iris)

```

### 1.2.4: Subsetting Dataframes
 
Subsetting datasets can be really helpful when you want to work with certain variables, especially when you have a large number of variables - imagine a dataframe with 100 columns! To subset dataframes in R, we use square brackets. Inside the square brackets, we need to specify what subset we want to extract. For dataframes, these will be specific rows or columns or both. Rows are specified first followed by a comma then columns are specified. If you want to subset columns only, i.e. keep all rows, you can simply not specify anything before the comma (and vice versa). Let's subset the Iris data to include the first column only.

```{r}
names(iris) # to see the column names
iris[,"Sepal.Length"] # specify the column name
iris[,1] # or specify the position of the column

```

As you can see you can specify the subset you want to extract using either the column name or the column's position.

Note, for a single variable you can also do:

```{r}
iris$Sepal.Length

```

To subset the Iris data to contain the columns "Sepal.Length" and "Petal.Length", you need to use the c() function.

```{r}
iris[,c("Sepal.Length","Petal.Length")]
iris[,c(1,3)]

```

Note that you can use head if you don't want all of the subsetted data to be displayed in the console.

```{r}
head(iris[,c("Sepal.Length","Petal.Length")])
head(iris[,c(1,3)])

```

To subset the Iris data to contain specific rows, you need to include the row numbers.

```{r}
iris[c(4,7,17),]

```

Similarly, you can subset by both rows and columns by including information before (rows) and after (columns) the comma inside the square brackets.
```{r}
iris[c(1,2,3,4),c(1,2)]
# note, if you have sequential row and/or column numbers you can use a colon instead of c()
iris[1:4,1:2] # this returns exactly the same as the previous line

```

You can also subset data based on conditions such as less than, greater than or equal to.

```{r}
iris[iris$Sepal.Width < 2.5,]
iris[iris$Sepal.Width > 4.0,]
iris[iris$Sepal.Width == 4.0,]
iris[iris$Species == "setosa",]

```


The above subsetting code just prints the subset in the console. To work with the subsetted data, e.g. analysis the subset, it is often useful to create a new object for the subset. For example, the object 'iris_sub' contains only data for plants with sepal width of less than 2.5.

```{r}
iris_sub <- iris[iris$Sepal.Width < 2.5,]
iris_sub
nrow(iris_sub)

```


### 1.2.5: Deleting from and adding to a dataframe  

Code for deleting rows and columns is similar to code for subsetting but instead of specifying the subset you want to keep, you specify the subset you want to delete, and insert a minus sign. 

```{r}
# For example, if you want to delete the first 100 rows:
iris[-(1:100),] 
# or the 2nd column:
iris[,-2]

```


Adding new data to an existing dataset can be really useful if you have found a new source of data or if you have collected new data.

To add rows to the bottom of a dataframe, we use the 'row bind' function, rbind().

```{r}
# print the tail end of the dataframe to see the bottom of the table
tail(iris)
# create a new object containing the new data
new_data <- c(6.0,3.0,5.0,1.0,'versicolor')
# create a new object containing the original iris data plus the new plant measurements
iris_updated <- rbind(iris, new_data)
# print the tail end of the new dataframe to check that the new data appears at the bottom of the table
tail(iris_updated)

# or you skip the step of creating the new_data object
iris_updated <- rbind(iris,c(6.0,3.0,5.0,1.0,'versicolor'))
tail(iris_updated)

```

In the above example, one row is added. Now let's add two rows:

```{r}
new_data <- data.frame(rbind(c(6.0,3.0,5.0,1.0,'versicolor'),c(4.1,3.2,5.4,1.1,'versicolor')))
names(new_data) <- names(iris)
iris_updated <- rbind(iris, new_data)
tail(iris_updated)

```


### 1.2.6: Optional

A) The aggregate function splits data into subsets and computes summary statistics for each. Test it out.

```{r}
?aggregate # read what the function does and see example code at the bottom of the help page
aggregate(Sepal.Length~Species, data=iris, mean)

```

B) Try out other subsets and summary statistics such as median, minimum or maximum.


# Abbey's Section

These following examples are taken from https://r4ds.had.co.nz/data-visualisation.html which goes into more detail should you wish! 

### 1.2.7 packages

R packages are basically add-ons to base R. Base R does a number of simple functions, but thanks to the open source ethos behind R the R community has built a large number of packages (over 14,000 on the CRAN where you downloaded R from) to solve common problems or offer new analysis techniques. This is the reason why R is so great. A package brings new functionality in the form of data, code, documentation and tests. You can download/install packages from the package tab in the files panel, or you can do it using the *install.packages* function. Once you have downloaded the package from CRAN (you only need to do this once), you need to make sure the package is installed on R using the *library* function.

Let's do this for ggplot2 which we will need for graphics. There are a number of packages to make graphs but ggplot2 is the most versatile and widely used. 

```{r}
install.packages("ggplot2")
library(ggplot2)
```
p.s. igrone the error here, this is just becuase I already have ggplot2 installed 

Most scripts you will see start with the required packages at the top, in addition to any required data. It is good practice to specify which packages your analysis requires as they are uninstalled when you re-start R and chunks of code won't work if you don't re-install them (and its way too easy to forget which chunk uses which package)

### 1.2.8 Iris flower data frame 

To start learning the grammar of graphics we are going to use a simple dataframe (df for short) - Fisher's Iris flower dataset. The data set consists of 50 samples from each of three species of Iris (*Iris setosa, Iris virginica and Iris versicolor*). Four features were measured from each sample: the length and the width of the sepals and petals, in centimeters.

Let's have a look at this quickly. 

```{r}
iris # run this line to view the df - as it is installed in base R nothing else is required  
```

```{r}
?iris # help and more information about the dataset
```

### 1.2.9 exploration of Iris

We are interested in understanding the relationship between Sepal length and Petal length - are they correlated? Is this a negative or positive correlation. 

The best way to look at this is in a scatterplot with all the data points ploted by septal length (on the x axis, bottom) and by petal legnth (on the y axis, left)

```{r}
# Scatterplot using ggplot 

ggplot(data = iris) + # here you tell R to use the function 'ggplot' to use the the iris df 
  geom_point(mapping = aes(x = Sepal.Length, y = Petal.Length)) # here you are saying you want points with another function which adds a layer to your plot
```

So the commands to make this plot are based on *functions* - ggplot() which creates a coordinate system that you add layers to and geom_point() which adds those layers creating the scatterplot. FYI, as we will soon find out there are tons of geom_ functions dependent on the type of plot you want to make. As were are interested in the relationship between two continuous variables a scatter plot makes sense. 

After the functions comes the *arguments* - the content of the brackets. The first argument of ggplot() is the dataset to use in the graph. So ggplot(data = iris) creates an empty graph (if you didn't add the layer you would have blank panel)

the gemo_point(mapping = aea()) argument defines how variables in your dataset are mapped to the visual properties. The mapping argument is always paired with aes(), and the x and y arguments of aes() specify which variables to map to the x and y axes. This is what is required to see something in your plot. You are basically saying: 

1: I want a plot please based on the iris data 
2: I want this plot to be a scatterplot with points
3: I want this plot to be of sepal length (X) and petal length (y)

That's it! You can change this template by change the *data, geom_function or mapping variables* to create a wide range of graphics using different data. 

You can see that ggplot2 is a lot about layering. You make a basic plot and then you add features to help you better understand it. So let's take this plot further. It looks like there is a positive relationship between sepal and petal length, however there is a bunch of data points in the far left corner which this does hold for - why is this? how can we explore this further? 

### 1.2.10 Adding aesthetics 

To better visualise our data we can use aesthetics by adding a third variable to the mapping arugment (the bit in the aes()). An aestheic is a visual property of the objects in your plot, which includes colour, size and shape of the data points. You are able in the syntax to alter these elements, both globally (i.e. for all points on the graph) and per group (i.e. different values are attributed to different species). 

Here we can use colour to map aesthetics in your plot to the variables in the iris dataset - let's do species to see if that helps us understand the data better. 

```{r}
ggplot(data = iris) + 
  geom_point(mapping = aes(x = Sepal.Length, y = Petal.Length, colour = Species)) # note that the text has remained the same but I have just added in the colour argument - note this can be spelt both in UK and US English! 
```
Now we can see that the linear relationship between sepal and petal legnth holds true for versicolor and viriginica but not for setosa! 

ggplot2 has automatically assigned a unique colour to each unique value of the species variable (called scaling) and provides you with a legend so you know what colour refers to what species. 

Let's now try other aesthetics 

```{r}
ggplot(data = iris) + 
  geom_point(mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species, shape = Species, size = Species))
```

So now we have added in size and shape agruments. Each of the different species are associated with different sizes of points and different shapes. R is giving us a warning that size is not advised for a discrete variable because it is an unordered variable (basically, it would make sense if larger species had larger points but R doesn't have this information to work from)

Also note that all three of these aesthetics have been included in the legend.  

So instead we could try changing the transparency of the points using the alpha argument. 


```{r}
ggplot(data = iris) + 
  geom_point(mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species, shape = Species, alpha = Species))
```

Now setosa points are hardly visible - not really useful. This is just to show you can change all these elements, but much is not necessaryily better and plots should be easy to understand! 

You can also set the aesthetic properties of your geom manually. For example, we can make all of the points in our plot pink, all the shapes circles or all the points larger. When you do this the global aesthetic change will overright anything in the mapping agrument 

```{r}
# colour
  ggplot(data = iris) + 
  geom_point(mapping = aes(x = Sepal.Length, y = Petal.Length, shape = Species), colour = "salmon") 

# shape
 ggplot(data = iris) + 
  geom_point(mapping = aes(x = Sepal.Length, y = Petal.Length, shape = Species), shape = 16)  # 16 = small circles. Note that this has overrode the shape = species in the mapping agrument. 
 
# size  
  ggplot(data = iris) + 
  geom_point(mapping = aes(x = Sepal.Length, y = Petal.Length, shape = Species), size = 3)  # bigger nunmber = bigger points
```
  
There is an amazing range of colours you can use in r: see this file http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf 
for names (replace the "salmon" above) and more info from http://www.cookbook-r.com/Graphs/Colors_(ggplot2)/ 

R has 25 build in shapes which are identified by numbers. Shapes change, as do their colour and fill. See: http://www.cookbook-r.com/Graphs/Shapes_and_line_types/ 

Because these changes to the plot are happening outside of the aes() they do not convey any information about the variable so generally less informative (but pretty!) 

### 1.2.11 adding layers to your plot 

From the selection of plots above I think the most useful is the first one with the colours denoted by species. Often scatter graphs come with lines to show the trends in the data. This can be done using a different *geom_function* 

geom are geometrical objects used to represent data and ggplot has over 40 of them. So the one you pick depends on the data type you want to represent and graph you want to make. So to add a line to a your existing scatterplot you need to use geom_smooth(), or a smooth line fitted to the data in the mapping argument. 


```{r}
  # add a line and 95% confidence intervals
  ggplot(data = iris) + 
    geom_point(mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)) +  # same as above and the ADD another layer
    geom_smooth(mapping = aes(x = Sepal.Length, y = Petal.Length), colour = "salmon") # adds smoothed line 
```

So we have added a loess smooth line with a 95% confidence region (as R tells you above by the info icon), and using the global aesthetic made it salmon coloured. Nice. But, if we know the relationship between sepal length and petal length is dependent on the species, it is probably better to have a line for each of these species. We do this in exactly the same way as we changed the aesthetics on the points by adding a third condition into the mapping argument. 

```{r}
# line for each of the species
  ggplot(data = iris) + 
    geom_point(mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)) +  # same as above and the ADD another layer
    geom_smooth(mapping = aes(x = Sepal.Length, y = Petal.Length, colour = Species)) # line is now by species
```

So now you can see a loess smoothed fit curve for each of the species. So this shows how you can add on layers to the basic graphic and how each geom_function can be changed using the mapping function. It is important to note that you cannot use the same arguments for all the geom types. For instance, you can't change the line 'shape' like a data point, but you can change the linetype, and make that specific to each species. 

To learn more about any single geom and what you can change in the argument see the help function by typing ?geom_smooth or ?geom_point

```{r}
# line for each of the species
  ggplot(data = iris) + 
    geom_point(mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)) +  # same as above and the ADD another layer
    geom_smooth(mapping = aes(x = Sepal.Length, y = Petal.Length, colour = Species, linetype = Species)) 
```

This feature doesn't add much to our current plot because we changed the colour, but very useful if the plot was black and white. 

Finally, you can change the line types between a loess curve or a regession line, and whether it has 95% CI or not. 

```{r}
# linear regression lines with 95% CI
  ggplot(data = iris) + 
    geom_point(mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)) +  # same as above and the ADD another layer
    geom_smooth(mapping = aes(x = Sepal.Length, y = Petal.Length, colour = Species), method =lm) # add linear regression line with 95% confidence as default
```

```{r}
# linear regression lines without 95% CI
  ggplot(data = iris) + 
    geom_point(mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)) +  # same as above and the ADD another layer
    geom_smooth(mapping = aes(x = Sepal.Length, y = Petal.Length, colour = Species), method =lm, se=FALSE) # add linear regression line with 95% confidence as default
```


### 1.2.12 streamlining your code 

Our code is working well, we can see the trends for the three species clearly. However, it's a bit long winded - more space to go wrong. For instance, if you want to change the x and y variable you need to do this in both places. It is always good to make your code as efficient as possible. We don't need to repeat the mapping for both geom_functions if we state it in the ggplot() function, ggplot2 then treats these mappings as global mappings and applies it to both geom in the graph. 


```{r}
ggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length)) + # mapping is now up here
  geom_point() + 
  geom_smooth()
```

If you place mappings in a geom function, ggplot2 will treat them as local mappings for the layer. It will use these mappings to extend or overwrite the global mappings for that layer only. This makes it possible to display different aesthetics in different layers. This means that you don't have the use the same aesthetics for all the gemo functions.

```{r}
ggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length)) + # global mapping is now up here
  geom_point(mapping = aes(colour = Species, shape = Species)) +  # local mappings
  geom_smooth(mapping = aes(linetype = Species)) # local mappings
```

### 1.2.13 facetting your plots 
The last element we will talk about now to add to your plot are facets because they are really useful and not complex to do. They are just another layer to add to the plot if you have categorical variable. Facets basically makes subplots that each display one subset of your data. 

The first argument of facet_wrap() should be a formula, which you create with ~ followed by a discrete variable name. 

```{r}
ggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length)) + 
  geom_point(mapping = aes(colour = Species, shape = Species)) + 
  geom_smooth(mapping = aes(colour = Species)) +
   facet_wrap(~ Species, nrow = 1) # facet wrap added for species, nrow is how many rows you want, I have said 1 becuase there are only three species. 
```

Now that it is faceted the species legend isn't really helpful. So let's remove it. 

```{r}
ggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length)) + 
  geom_point(mapping = aes(colour = Species, shape = Species), show.legend = FALSE) + 
  geom_smooth(mapping = aes(colour = Species), show.legend = FALSE) + # note you need to remove from all mappings
   facet_wrap(~ Species, nrow = 1) # facet wrap added for species, nrow is how many rows you want, I have said 1 becuase there are only three species. 
```

### 1.2.15 axis 

Looking at the plot I would say it's a bit annoying that the ticks on the y axis (the numbers) are only every 2, I think they should be every 1 for consistency with the y.

To do this we just add another layer with the + 

```{r}
ggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length)) + 
  geom_point(mapping = aes(colour = Species, shape = Species), show.legend = FALSE) + 
  geom_smooth(mapping = aes(colour = Species), show.legend = FALSE) + 
   facet_wrap(~ Species, nrow = 1)  + 
    coord_cartesian(ylim=c(1, 7)) + # this zooms into the space between 1-7 
     scale_y_continuous(breaks=seq(1, 7, 1))  # Ticks from 1-7, every 1
```

### 1.2.16 text
Finally, I think it would be nice if we didn't have the . between Sepal and length and Petal and length. So we need to change the text on the axes. 

Again you just need to add the ylab (label for the y axis) and xlab (label for the x axis) functions to the existing plot. 

```{r}
ggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length)) + 
  geom_point(mapping = aes(colour = Species, shape = Species), show.legend = FALSE) + 
  geom_smooth(mapping = aes(colour = Species), show.legend = FALSE) + 
   facet_wrap(~ Species, nrow = 1)  + 
    coord_cartesian(ylim=c(1, 7)) + 
     scale_y_continuous(breaks=seq(1, 7, 1)) + 
      ylab("Petal Length (cm)") + 
        xlab("Sepal Length (cm)")
```

I'm pretty happy with this! This is how we build graphs - we start simple and then build in elements to best visualise the data. 

### 1.2.17 Exercises 

**A)** Plot the relationship between sepal length and petal length (as above) but this time map petal width on to colour. How do the aesthetics behaviour differently for a continuous variable (like width)? Write a one sentence summary of the plot.

**B)** What is wrong with this code? Why are the points not blue?

```{r}
ggplot(data = iris) + 
  geom_point(mapping = aes(x = Sepal.Length, y = Petal.Length, color = "blue"))
```

**C)** Make a scatterplot between Petal.Length and Species. Does this still look like a Scatterplot. Try geom_boxplot. 

**D)** What is wrong with the following code? Did you see the error message?
```{r}
ggplot(data = iris) 
+ geom_point(mapping = aes(x = Sepal.Length, y = Petal.Length))
```

**E)** Make a scatter plot between sepal and petal width. Add in aesthetics to better visualise the data. Write a one sentence summary of the plot.  


### 1.2.18 Problem shoting 

It is really common to run a line of code and it doesn't work. Normally it is a misplaced character, or an unclosed bracket. Check that every ( has a ) and every " has a ".  

Captials also matter in R - note that Sepal.Length will work but sepal.length will not! 

Sometimes you will run the code and nothing happens. Check the left-hand of your console: if its a +, it means that R doesn’t think you have typed a complete expression and its waiting for you to finish it. In this case, its usually easy to start from scratch again by pressing ESCAPE to abort processing the current command.

One common problem when creating ggplot2 graphics is to put the + in the wrong place: it has to come at the end of the line, not the start. 

If you’re still stuck, try the help. You can get help about any R function by running ?function_name in the console, or selecting the function name and pressing F1 in RStudio. Don’t worry if the help doesn’t seem that helpful - instead skip down to the examples and look for code that matches what you’re trying to do.

If that doesn’t help, carefully read the error message. Sometimes the answer will be buried there! But when you’re new to R, the answer might be in the error message but you don’t yet know how to understand it. Another great tool is Google: try googling the error message, as it’s likely someone else has had the same problem, and has gotten help online.



### 1.2.19 Resources 

https://www.rstudio.com/resources/cheatsheets/ - cheatsheet for ggplot2 

https://r4ds.had.co.nz/data-visualisation.html - R for Data Science 

http://www.cookbook-r.com/Graphs/ - Cookbook for R Graphics 
